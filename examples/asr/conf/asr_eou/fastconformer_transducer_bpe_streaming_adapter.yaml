# It contains the default values for training a cache-aware streaming FastConformer-Transducer ASR+EOU model, large size (~115M) with sub-word encoding.

# You may find more detail:
# FastConformer here: https://docs.nvidia.com/deeplearning/nemo/user-guide/docs/en/stable/asr/models.html#fast-conformer
# Cache-aware Conformer here: https://docs.nvidia.com/deeplearning/nemo/user-guide/docs/en/stable/asr/models.html#cache-aware-streaming-conformer
# FastConformer-Transducer's architecture config, along with the optimal batch size and precision: NeMo/examples/asr/conf/fastconformer/fast-conformer_transducer_bpe.yaml

name: "FastConformer-Transducer-BPE-Streaming-EOU-adapter"

model:
  token_init_method: "constant"  # choices=['min', 'max', 'mean', 'constant']
  token_init_weight_value: null  # only applicable when token_init_method='constant'
  token_init_bias_value: -1000.0  # only applicable when token_init_method='constant'

  sample_rate: 16000
  compute_eval_loss: false # eval samples can be very long and exhaust memory. Disable computation of transducer loss during validation/testing with this flag.
  log_prediction: true # enables logging sample predictions in the output during training
  skip_nan_grad: false

  model_defaults:
    enc_hidden: ${model.encoder.d_model}
    pred_hidden: 640
    joint_hidden: 640

  adapter:
    ### Config of the adapter training/eval script ###
    adapter_name: "eou-adapter"  # Name of the adapter, used by the script
    adapter_type: "linear"  # Type of the adapter. Corresponds to the subconfigs below.
    adapter_module_name: null  # Name of the adapter module. Combine multiple modules with '+' between module names.
    adapter_state_dict_name: "adapters.pt"  # If the individual adapters must be saved, a file name can be provided here. null disables this.

    ### Adapter Configs ###
    # Linear / Houlsby Adapter (https://arxiv.org/abs/1902.00751)
    linear:
      # Config of the adapter module itself
      _target_: nemo.collections.common.parts.adapter_modules.LinearAdapter
      in_features: ${model.encoder.d_model}  # User must provide the output dimension of the layers of the model, which is the input dimension of this adapter.
      dim: 32  # The hidden dimension of the adapter, as chosen by user, but small values are preferred to reduce param count.
      activation: swish
      norm_position: 'pre'  # Can be `pre` or `post`
      dropout: 0.0  # float, dropout for the adapter

      # Adapter strategy config
      adapter_strategy:
        _target_: nemo.core.classes.mixins.adapter_mixin_strategies.ResidualAddAdapterStrategy
        stochastic_depth: 0.0  # float, setting to > 0 will enable stochastic depth for each adapter block.
        l2_lambda: 0.0  # float, setting to > 0 will enable l2 norm auxiliary loss for each adapter's output.

    # Tiny-Attention Adapter (https://arxiv.org/abs/2211.01979)
    # NOTE: Only supported for Attention based encoders. Make sure to pass `adapter_module_name` as "encoder"
    tiny_attn:
      # Config of the adapter module itself
      # Defaults to Relative Positional Encoding MHA
      # _target_ can instead be <import_path>.MultiHeadAttentionAdapter if Conformer was originally using Absolute Positional Encoding.
      _target_: nemo.collections.asr.parts.submodules.adapters.multi_head_attention_adapter_module.RelPositionMultiHeadAttentionAdapter
      n_feat: ${model.encoder.d_model}  # User must provide the output dimension of the layers of the model, which is the input dimension of this adapter.
      n_head: 1  # Number of heads for attention.
      proj_dim: -1  # Can be `null` - to avoid projection, > 0 for explicit dim, or -1 to default to `n_head`
      dropout_rate: 0.0  # float, dropout for the adapter

      # Adapter strategy config
      adapter_strategy:
        _target_: nemo.collections.asr.parts.submodules.adapters.multi_head_attention_adapter_module.MHAResidualAddAdapterStrategy
        stochastic_depth: 0.0  # float, setting to > 0 will enable stochastic depth for each adapter block.
        l2_lambda: 0.0  # float, setting to > 0 will enable l2 norm auxiliary loss for each adapter's output.

    # Optional global config available to all adapters at a global level.
    # A global config is shared across every layer of the adapters, defining global properties rather
    # than properties local to the adapter (as defined above).
    # This can be useful in order to select *which type of adapter* is added, *what adapters to enable*,
    # and further global operations that can decide dynamically how to support the requested adapter.
    global_cfg:
      check_encoder_adapter: True  # ASR adapter key, determines whether to check if encoder adapter modules is supported
      check_decoder_adapter: True  # ASR adapter key, determines whether to check if decoder adapter modules is supported
      check_joint_adapter: True  # ASR adapter key, determines whether to check if joint adapter modules is supported

  freeze_decoder: ${model.adapter.global_cfg.check_decoder_adapter}
  freeze_joint: ${model.adapter.global_cfg.check_joint_adapter}

  train_ds:
    manifest_filepath: ???
    tarred_audio_filepaths: null
    sample_rate: ${model.sample_rate}
    max_duration: 30 # you may need to update it for your dataset
    min_duration: 0.1
    defer_setup: true
    batch_duration: null  # you may disable batch_duration by setting it to `null`
    batch_size: 16 
    shuffle: true
    drop_last: true
    num_workers: 8
    pin_memory: true
    quadratic_duration: 30
    num_buckets: 30
    num_cuts_for_bins_estimate: 10000
    bucket_buffer_size: 10000
    shuffle_buffer_size: 10000

    ignore_eob_label: true  # ignore backchannel and treat them the same as EOU
    random_padding:
      prob: 0.99
      min_pad_duration: 1.0  # minimum duration of pre/post padding in seconds
      max_pad_duration: 10.0  # maximum duration of pre/post padding in seconds
      max_total_duration: 40.0  # maximum total duration of the padded audio in seconds
      pad_distribution: 'uniform'  # distribution of padding duration, 'uniform' or 'normal'
      normal_mean: 0.5  # mean of normal distribution used when pad_distribution='normal'
      normal_std: 2.0  # standard deviation of normal distribution  used when pad_distribution='normal'
  
    augmentor:
      white_noise:
        prob: 0.9
        min_level: -90
        max_level: -46
      gain:
        prob: 0.2
        min_gain_dbfs: -10.0
        max_gain_dbfs: 10.0
      noise:
        prob: 0.9
        manifest_path: ???
        min_snr_db: 0
        max_snr_db: 20
        max_gain_db: 300.0

  validation_ds:
    manifest_filepath: ???
    tarred_audio_filepaths: null
    sample_rate: ${model.sample_rate}
    max_duration: 30 # you may need to update it for your dataset
    min_duration: 0.1
    defer_setup: true
    batch_duration: null  # you may disable batch_duration by setting it to `null`
    batch_size: 16 
    shuffle: false
    num_workers: 8
    pin_memory: true
    quadratic_duration: 30
    num_buckets: 30
    num_cuts_for_bins_estimate: 10000
    bucket_buffer_size: 10000
    shuffle_buffer_size: 10000
    ignore_eob_label: true  # ignore backchannel and treat them the same as EOU

  test_ds:
    manifest_filepath: null
    tarred_audio_filepaths: null
    sample_rate: ${model.sample_rate}
    max_duration: 30 # you may need to update it for your dataset
    min_duration: 0.1
    defer_setup: true
    batch_duration: null  # you may disable batch_duration by setting it to `null`
    batch_size: 16 
    shuffle: false
    num_workers: 8
    pin_memory: true
    quadratic_duration: 30
    num_buckets: 30
    num_cuts_for_bins_estimate: 10000
    bucket_buffer_size: 10000
    shuffle_buffer_size: 10000
    ignore_eob_label: true  # ignore backchannel and treat them the same as EOU

  # You may find more detail on how to train a tokenizer at: /scripts/tokenizers/process_asr_text_tokenizer.py
  # We recommend to use vocab size of 1024 with SPE Unigram for most languages
  tokenizer:
    dir: ???  # path to directory which contains either tokenizer.model (bpe) or vocab.txt (for wpe)
    type: bpe  # Can be either bpe (SentencePiece tokenizer) or wpe (WordPiece tokenizer)

  preprocessor:
    _target_: nemo.collections.asr.modules.AudioToMelSpectrogramPreprocessor
    sample_rate: ${model.sample_rate}
    normalize: "NA" # No normalization for mel-spectogram makes streaming easier
    window_size: 0.025
    window_stride: 0.01
    window: "hann"
    features: 80
    n_fft: 512
    frame_splicing: 1
    dither: 0.00001
    pad_to: 0

  spec_augment:
    _target_: nemo.collections.asr.modules.SpectrogramAugmentation
    freq_masks: 2 # set to zero to disable it
    time_masks: 10 # set to zero to disable it
    freq_width: 27
    time_width: 0.05

  encoder:
    _target_: nemo.collections.asr.modules.ConformerEncoder
    feat_in: ${model.preprocessor.features}
    feat_out: -1 # you may set it if you need different output size other than the default d_model
    n_layers: 17
    d_model: 512
    use_bias: false # whether to apply bias in the feedforward, MHA and convolution modules

    # Sub-sampling parameters
    subsampling: dw_striding # vggnet, striding, stacking or stacking_norm, dw_striding
    subsampling_factor: 8 # must be power of 2 for striding and vggnet
    subsampling_conv_channels: 256 # set to -1 to make it equal to the d_model
    causal_downsampling: true

    # Feed forward module's params
    ff_expansion_factor: 4

    # Multi-headed Attention Module's params
    self_attention_model: rel_pos # rel_pos or abs_pos
    n_heads: 8 # may need to be lower for smaller d_models

    # [left, right] specifies the number of steps to be seen from left and right of each step in self-attention
    # for att_context_style=regular, the right context is recommended to be a small number around 0 to 3 as multiple-layers may increase the effective right context too large
    # for att_context_style=chunked_limited, the left context need to be dividable by the right context plus one
    # look-ahead(secs) = att_context_size[1]*subsampling_factor*window_stride, example: 13*8*0.01=1.04s

    # For multi-lookahead models, you may specify a list of context sizes. During the training, different context sizes would be used randomly with the distribution specified by att_context_probs.
    # The first item in the list would be the default during test/validation/inference.
    # An example of settings for multi-lookahead:
    #    att_context_size: [[70,13],[70,6],[70,1],[70,0]]
    #    att_context_probs: [0.25, 0.25, 0.25, 0.25, 0.25]
    att_context_size: [70, 1] # -1 means unlimited context
    att_context_style: chunked_limited # regular or chunked_limited
    att_context_probs: null

    xscaling: false # scales up the input embeddings by sqrt(d_model)
    pos_emb_max_len: 5000

    # Convolution module's params
    conv_kernel_size: 9
    conv_norm_type: 'layer_norm' # batch_norm or layer_norm or groupnormN (N specifies the number of groups)

    # conv_context_size can be"causal" or a list of two integers while conv_context_size[0]+conv_context_size[1]+1==conv_kernel_size
    # null means [(kernel_size-1)//2, (kernel_size-1)//2], and 'causal' means [(kernel_size-1), 0]
    # Recommend to use causal convolutions as it would increase the effective right context and therefore the look-ahead significantly
    conv_context_size: causal

    ### regularization
    dropout: 0.1 # The dropout used in most of the Conformer Modules
    dropout_pre_encoder: 0.1 # The dropout used before the encoder
    dropout_emb: 0.0 # The dropout used for embeddings
    dropout_att: 0.1 # The dropout for multi-headed attention modules

    # set to non-zero to enable stochastic depth
    stochastic_depth_drop_prob: 0.0
    stochastic_depth_mode: linear  # linear or uniform
    stochastic_depth_start_layer: 1

  decoder:
    _target_: nemo.collections.asr.modules.RNNTDecoder
    normalization_mode: null # Currently only null is supported for export.
    random_state_sampling: false # Random state sampling: https://arxiv.org/pdf/1910.11455.pdf
    blank_as_pad: true # This flag must be set in order to support exporting of RNNT models + efficient inference.

    prednet:
      pred_hidden: ${model.model_defaults.pred_hidden}
      pred_rnn_layers: 1
      t_max: null
      dropout: 0.2

  joint:
    _target_: nemo.collections.asr.modules.RNNTJoint
    log_softmax: null  # 'null' would set it automatically according to CPU/GPU device
    preserve_memory: false  # dramatically slows down training, but might preserve some memory

    # Fuses the computation of prediction net + joint net + loss + WER calculation
    # to be run on sub-batches of size `fused_batch_size`.
    # When this flag is set to true, consider the `batch_size` of *_ds to be just `encoder` batch size.
    # `fused_batch_size` is the actual batch size of the prediction net, joint net and transducer loss.
    # Using small values here will preserve a lot of memory during training, but will make training slower as well.
    # An optimal ratio of fused_batch_size : *_ds.batch_size is 1:1.
    # However, to preserve memory, this ratio can be 1:8 or even 1:16.
    # Extreme case of 1:B (i.e. fused_batch_size=1) should be avoided as training speed would be very slow.
    fuse_loss_wer: true
    fused_batch_size: 4

    jointnet:
      joint_hidden: ${model.model_defaults.joint_hidden}
      activation: "relu"
      dropout: 0.2

  decoding:
    strategy: "greedy_batch" # can be greedy, greedy_batch, beam, tsd, alsd.

    # greedy strategy config
    greedy:
      max_symbols: 10

    # beam strategy config
    beam:
      beam_size: 2
      return_best_hypothesis: False
      score_norm: true
      tsd_max_sym_exp: 50  # for Time Synchronous Decoding
      alsd_max_target_len: 2.0  # for Alignment-Length Synchronous Decoding

  # config for InterCTC loss: https://arxiv.org/abs/2102.03216
  # specify loss weights and which layers to use for InterCTC
  # e.g., to reproduce the paper results, set loss_weights: [0.3]
  # and apply_at_layers: [8] (assuming 18 layers). Note that final
  # layer loss coefficient is automatically adjusted (to 0.7 in above example)
  interctc:
    loss_weights: []
    apply_at_layers: []

  loss:
    loss_name: "default"
    warprnnt_numba_kwargs:
      # FastEmit regularization: https://arxiv.org/abs/2010.11148
      # You may enable FastEmit to increase the accuracy and reduce the latency of the model for streaming
      # You may set it to lower values like 1e-3 for models with larger right context
      fastemit_lambda: 3e-2  # Recommended values to be in range [1e-4, 1e-2], 0.001 is a good start.
      clamp: -1.0  # if > 0, applies gradient clamping in range [-clamp, clamp] for the joint tensor only.

  optim:
    name: adamw
    lr: 5.0 #  1e-4
    # optimizer arguments
    betas: [0.9, 0.98]
    weight_decay: 1e-3

    # scheduler setup
    sched:
      name: NoamAnnealing  # NoamAnnealing CosineAnnealing
      # scheduler config override
      d_model: ${model.encoder.d_model}
      warmup_steps: 10000
      warmup_ratio: null
      min_lr: 1e-6

trainer:
  devices: -1 # number of GPUs, -1 would use all available GPUs
  num_nodes: 1
  max_epochs: -1
  max_steps: 100000 # computed at runtime if not set
  val_check_interval: 1000 # an int for number of iterations
  limit_train_batches: ${trainer.val_check_interval}
  accelerator: auto
  strategy:
    _target_: lightning.pytorch.strategies.DDPStrategy
    gradient_as_bucket_view: true
  accumulate_grad_batches: 1
  gradient_clip_val: 1.0
  precision: 32 # 16, 32, or bf16
  log_every_n_steps: 10  # Interval of logging.
  enable_progress_bar: True
  num_sanity_val_steps: 0 # number of steps to perform validation steps for sanity check the validation process before starting the training, setting to 0 disables it
  check_val_every_n_epoch: 1 # number of evaluations on validation every n epochs
  sync_batchnorm: true
  enable_checkpointing: False  # Provided by exp_manager
  logger: false  # Provided by exp_manager
  benchmark: false # needs to be false for models with variable-length speech input as it slows down training
  use_distributed_sampler: false

exp_manager:
  exp_dir: null
  name: ${name}
  create_tensorboard_logger: true
  create_checkpoint_callback: true
  checkpoint_callback_params:
    # in case of multiple validation sets, first one is used
    monitor: "val_wer"
    mode: "min"
    save_top_k: 5
    always_save_nemo: True # saves the checkpoints as nemo files instead of PTL checkpoints
  resume_from_checkpoint: null # The path to a checkpoint file to continue the training, restores the whole state including the epoch, step, LR schedulers, apex, etc.
  resume_if_exists: false
  resume_ignore_no_checkpoint: false

  create_wandb_logger: false
  wandb_logger_kwargs:
    name: null
    project: null
